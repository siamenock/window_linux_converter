// RSA.cpp: 콘솔 응용 프로그램의 진입점을 정의합니다.
//#pragma warning(disable: 4996)


#include <stdio.h>
#include "../include/big_integer.h"

int a = 0;

void _div(BigInt* A, BigInt iA, int w, int room) {
	BigInt two = newBigInt(2);
	BigInt temp_w = newBigInt(w);
	BigInt W = powB(&two, &temp_w);
	BigInt wB = temp_w;
	int v = room * w;

	for (int i = 0; i < room; i++) {
		BigInt temp_pow = powB(&two, &temp_w);
		A[i] = modB(&iA, &W);
		iA = divB(&iA, &temp_pow);
	}
}

BigInt gcd(BigInt p, BigInt q) {
	BigInt zero = newBigInt(0);
	while (cmp(&zero, &q) != 0) {
		BigInt temp = modB(&p, &q);
		p = q;
		q = temp;
	}

	p.sign = POSITIVE;
	return p;
}

BigInt lcm(BigInt p, BigInt q) {
	BigInt gcd_value = gcd(p, q);
	BigInt zero = newBigInt(0);
	if (cmp(&gcd_value, &zero) == 0)
		return zero;

	BigInt mulVal = mulB(&p, &q);
	BigInt val = divB(&mulVal, &gcd_value);
	val.sign = POSITIVE;

	return val;
}

BigInt inverse(int k, BigInt p) {
	if (k == 0)
		return newBigInt(0);
	if (k < 0) {
		BigInt temp_inverse = inverse(-k, p);
		return subB(&p, &temp_inverse);
	}

	BigInt zero = newBigInt(0);
	BigInt s = zero, old_s = newBigInt(1);
	BigInt t = newBigInt(1), old_t = zero;
	BigInt r = p, old_r = newBigInt(k);

	while (cmp(&r, &zero) != 0) {
		BigInt quotient = divB(&old_r, &r);
		BigInt temp;
		BigInt mulVal;

		temp = r;
		mulVal = mulB(&quotient, &r);
		r = subB(&old_r, &mulVal);
		old_r = temp;

		temp = s;
		mulVal = mulB(&quotient, &s);
		s = subB(&old_s, &mulVal);
		old_s = temp;

		temp = t;
		mulVal = mulB(&quotient, &t);
		t = subB(&old_t, &mulVal);
		old_t = temp;

	}

	BigInt gcd = old_r;
	BigInt x = old_s;
	BigInt y = old_t;
	BigInt one = newBigInt(1);

	if (cmp(&gcd, &one) != 0) {
		printf("error! gcd is 1\n");
		exit(1);
	}

	BigInt temp_k = newBigInt(k);
	BigInt temp = mulB(&temp_k, &x);
	temp = modB(&temp, &p);
	if (cmp(&temp, &one) != 0) {
		printf("error! (k * x) %% p is 1\n");
		exit(1);
	}

	return modB(&x, &p);
}

BigInt MM(BigInt* iA, BigInt* iB, BigInt* iP) {
	BigInt mulVal = mulB(iA, iB);
	return modB(&mulVal, iP);
}

BigInt LR(BigInt M, BigInt e, BigInt N, BigInt R, BigInt hR) {
	BigInt T = newBigInt(1);
	BigInt zero = newBigInt(0);
	BigInt one = newBigInt(1);
	BigInt two = newBigInt(2);
	a = 0; //미사용 의문

	BigInt modVal = modB(&e, &two);
	if (cmp(&modVal, &zero) == 0) {
		e = addB(&e, &one);
		while (cmp(&e, &zero) > 0) {
			T = MM(&T, &T, &N);
			a += a;
			if (cmp(&e, &hR) > 0)
				T = MM(&T, &M, &N);

			leftShift(&e);
			e = modB(&e, &R);
		}
	}
	else {
		while (cmp(&e, &zero) > 0) {
			T = MM(&T, &T, &N);
			a += a;
			if (cmp(&e, &hR) >= 0)
				T = MM(&T, &M, &N);

			leftShift(&e);
			e = modB(&e, &R);
		}
	}

	T = MM(&one, &T, &N);

	return T;
}

int main(int argc, char** argv) {
	FILE* re = fopen("./output/RSA Result.txt", "w"); // 리눅스 맞게 수정
	BigInt zero = newBigInt(0);
	BigInt one = newBigInt(1);
	BigInt two = newBigInt(2);
	BigInt num;
	a = 0;
	int b = 0;
	int w = 256;
	int room = 8;
	int room_1 = 4;
	char buff[300];
	while (a < 1) {
		printf("//////////////////////////////////\n");
		printf("//// Verification of RSA-2048 ////\n");
		printf("//////////////////////////////////\n");
		printf("*************************************************************************\n");
		printf("**** Enter Private Keys(P and Q) of 2,048-bit in Hexa-Decimal format ****\n");
		printf("*************************************************************************\n");
		char cP[3000];
		BigInt P;
		printf("P: ");
		scanf("%s", cP);
		P = atob(cP);

		num = newBigInt(2047);
		BigInt R = powB(&two, &num);
		char cQ[3000];
		BigInt Q;
		printf("Q: ");
		scanf("%s", cQ);
		Q = atob(cQ);

		BigInt div_Q[8];
		_div(div_Q, Q, w, room_1);
		BigInt div_P[8];
		_div(div_P, P, w, room_1);
		BigInt L = lcm(subB(&P, &one), subB(&Q, &one));
		BigInt N = mulB(&P, &Q);
		int e = 65537;
		BigInt D = inverse(e, L);
		printf("\n");
		printf("#### Private key generated (D) ####\n");
		BigInt div_D[8];
		_div(div_D, D, w, room);
		b = 7;
		while (b >= 0) {
			btoa(&div_D[b], buff, 16, 300);
			printf("0x%s\n", buff);
			b--;
		}/////
		printf("\n");
		printf("#### Public Key (E) generated by algorithm ####\n");
		printf("0x%x", e);
		printf("\n");
		printf("#### Public Key (N) generated by algorithm ####\n");
		BigInt div_N[8];
		_div(div_N, N, w, room);
		b = 7;
		while (b >= 0) {
			btoa(&div_N[b], buff, 16, 300);
			printf("0x%s\n", buff);
			b--;
		}

		printf("\n");
		printf("****************************************\n");
		printf("**** Enter Message of 2,048-bit (M) ****\n");
		printf("****************************************\n");
		char m[3000];
		BigInt M;
		printf("M: ");
		scanf("%s", m);
		M = atob(m);
		BigInt div_M[8];
		_div(div_M, M, w, room);
		BigInt hR = powB(&two, &num);
		num = newBigInt(2048);
		R = powB(&two, &num);
		printf("\n");
		printf("################################\n");
		BigInt E = newBigInt(e);
		BigInt C = LR(M, E, N, R, hR);
		printf("#### RSA Encryption Results ####\n");
		BigInt div_C[8];
		_div(div_C, C, w, room);
		b = 7;
		while (b >= 0) {
			btoa(&div_C[b], buff, 16, 300);
			printf("0x%s\n", buff);
			b--;
		}
		printf("\n");
		BigInt P_P = LR(C, D, N, R, hR);
		printf("#### RSA Decryption Results ####\n");
		BigInt div_P_P[8];
		_div(div_P_P, P_P, w, room);
		b = 7;
		while (b >= 0) {
			btoa(&div_P_P[b], buff, 16, 300);
			printf("0x%s\n", buff);
			b--;
		}

		BigInt V = subB(&P_P, &M);
		if (cmp(&V, &zero) != 0) {
			printf("Error");
			exit(1);
		}
		a++;

		fprintf(re, "/////////////////////////////////// \n");
		fprintf(re, "///// Verification of RSA-2048 //// \n");
		fprintf(re, "/////////////////////////////////// \n");
		fprintf(re, "************************************************************************* \n");
		fprintf(re, "**** Enter Private Keys(P and Q) of 2,048-bit in Hexa-Decimal format **** \n");
		fprintf(re, "************************************************************************* \n");

		btoa(&div_P[3], buff, 16, 300);
		fprintf(re, "P:%s \n", buff);

		b = 2;
		while (b >= 0) {
			btoa(&div_P[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, "\n");

		btoa(&div_Q[3], buff, 16, 300);
		fprintf(re, "Q:%s \n", buff);
		b = 2;
		while (b >= 0) {
			btoa(&div_Q[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, "\n");
		fprintf(re, "#### Private key generated (D) #### \n");

		b = 7;
		while (b >= 0) {
			btoa(&div_D[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, "\n");
		fprintf(re, "#### Public Key (E) generated by algorithm #### \n");
		fprintf(re, "%x \n", e);
		fprintf(re, " \n");
		fprintf(re, "#### Public Key (N) generated by algorithm #### \n");

		b = 7;
		while (b >= 0) {
			btoa(&div_N[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, " \n");

		fprintf(re, " \n");
		fprintf(re, "**************************************** \n");
		fprintf(re, "**** Enter Message of 2,048-bit (M) **** \n");
		fprintf(re, "**************************************** \n");

		b = 7;
		while (b >= 0) {
			btoa(&div_M[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, " \n");

		fprintf(re, " \n");
		fprintf(re, "################################ \n");
		fprintf(re, "#### RSA Encryption Results #### \n");

		b = 7;
		while (b >= 0) {
			btoa(&div_C[b], buff, 16, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, " \n");

		fprintf(re, " \n");
		fprintf(re, "#### RSA Decryption Results #### \n");

		b = 7;
		while (b >= 0) {
			btoa(&div_P_P[b], buff, 10, 300);
			fprintf(re, "  %s \n", buff);
			b--;
		}
		fprintf(re, " \n");
	}

	return 0;
}


